<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Introduction to Monkey C</title>
	<meta name="author" content="Garmin International"/>
	<meta name="date" content="July 10, 2020"/>
	<link type="text/css" rel="stylesheet" href="resources/programmers-guide/style.css"/>
	<meta name="copyright" content="Introduction to Monkey C version 3.2, Copyright 2020 Garmin, International."/>
</head>
<body>

<link href="resources/programmers-guide/google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
<script src="resources/programmers-guide/jquery-1.11.3.min.js"></script>
<script>
    $(document).ready( function() {
        $( 'pre' ).addClass( 'prettyprint' );
    } );
</script>
<script src="resources/programmers-guide/google-code-prettify/run_prettify.js"></script>
<div id="connect_iq_logo">
<figure>
<img src="resources/programmers-guide/connect_iq_logo.png" style="max-width:471px;" title="Powered by Garmin" />
</figure>
</div>
<div id="title">Introduction to Monkey C</div>
<div id="tagline">Learning the Language You Didn&#8217;t Know You Already Knew</div>
<div class="clear"></div>

<h1 id="tableofcontents">Table of Contents</h1>
<div id="toc">

<p>{{monkey_c_toc.md}}</p>
</div>

<h1 id="hellomonkeyc">Hello Monkey C!</h1>
<figure>
<img src="resources/programmers-guide/smart-monkey.png" style="max-width:300px;" title="Code Monkey get up get coffee..." />
</figure>

<p>There is no better way to learn Monkey C than by jumping right in. Let&#8217;s take a look at the application object of a watch face.</p>

<pre><code class="java">using Toybox.Application as App;
using Toybox.System;

class MyProjectApp extends App.AppBase {

    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView() {
        return [ new MyProjectView() ];
    }
}
</code></pre>

<p>If this looks familiar and non-threatening, that&#8217;s the point. Monkey C is intended to be the language you didn&#8217;t know you already knew.</p>

<p>At the top is a using statement, which is analogous to C++&#8217;s <code>using</code> statement, or an <code>import</code> in Java&trade;, Ruby, or Python&trade;. <code>using</code> statements lexically bring modules into our name space. After a <code>using</code> clause, we can refer to a module by its shortened name (in this case <code>System</code>). <code>Toybox</code> is the root module for Monkey C system modules; all the cool toys are kept in there.</p>

<p>To print out values to the debug console, use:</p>

<pre><code class="typescript">System.println( &quot;Hello Monkey C!&quot; );
</code></pre>

<p><code>System</code> refers to the <code>Toybox.System</code> module we imported with the <code>using</code> statement. Unlike Java namespaces, modules in Monkey C are static objects that can contain functions, classes, and variables. The <code>println()</code> function should be familiar to Java programmers&mdash;it prints a string and automatically adds a new line. The <code>System</code> module has a number of useful functions:</p>

<ul>
<li><code>print</code> and <code>println</code> send output to the console</li>
<li><code>getTimer</code> returns the current millisecond timer. The value is a 32 bit integer representing the number of milliseconds the system has been running. The value can be used for timing but is allowed to roll over.</li>
<li><code>getSystemStats</code> provides statistics from the runtime system</li>
<li><code>exit</code> will terminate your application</li>
<li><code>error</code> will exit your application while logging an error message</li>
</ul>

<h2 id="differencesfromotherlanguages">Differences From Other Languages</h2>

<p>As Italian and Spanish derive from Latin, Monkey C derives heavily from other popular languages. C, Java&trade;, JavaScript, Python&trade;, Lua, Ruby, and PHP all influenced the design for Monkey C. If you are familiar with any of those languages, Monkey C should be easy to pick up.</p>

<h3 id="java">Java</h3>

<p>Like Java, Monkey C compiles into byte code that is interpreted by a virtual machine. Also like Java, all objects are allocated on the heap, and the virtual machine cleans up memory (Java through garbage collection, Monkey C through reference counting). Unlike Java, Monkey C does not have primitive types&mdash;integers, floats, and chars are objects. This means primitives can have methods just like other objects.</p>

<p>While Java is a statically typed language, Monkey C is <a href="https://en.wikipedia.org/wiki/Duck_typing"><em>duck typed</em></a>. In Java, the developer must declare the types for all parameters of a function, and declare the return value type. The Java compiler checks these at compile time to ensure type safety. Duck typing is the concept of &#8220;if it walks like a duck, and quacks like a duck, then it must be a duck&#8221;<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a>. For example:</p>

<pre><code class="typescript">function add( a, b ) {
    return a + b;
}

function thisFunctionUsesAdd() {
    var a = add( 1, 3 ); // Return  4
    var b = add( &quot;Hello &quot;, &quot;World&quot; ); // Returns &quot;Hello World&quot;
}
</code></pre>

<p>The Monkey C compiler does not verify type safety, and instead causes a runtime error if a function mishandles a method.</p>

<p>Monkey C modules serve a similar purpose as Java packages, but unlike packages, modules can contain variables and functions. It is common for static methods to exist in the module as opposed to a particular class.</p>

<h3 id="luajavascript">Lua/JavaScript</h3>

<p>The main difference between JavaScript or Lua and Monkey C is that functions in Monkey C are not first class. In JavaScript, a function can be passed to handle a callback:</p>

<pre><code class="javascript">function wakeMeUpBeforeYouGoGo() {
    // Handle completion
}

// Do a long running thing, and pass callback to call when done.
doLongRunningTask( wakeMeUpBeforeYouGoGo );
</code></pre>

<p>In Lua, to create an object, you bind functions to a hash table:</p>

<pre><code class="lua">function doSomethingFunction( me ) {
    // Do something here
}

// Constructor for MyObject
function newMyObject() {
    local result = {};
    result[&quot;doSomething&quot;] = doSomethingFunction;
}
</code></pre>

<p>Neither of these techniques works in Monkey C, because functions are bound to the object they are created in.</p>

<p>To create a callback in Monkey C, create a <em>Method object</em>. Method objects are a combination of the function and the object instance or module they originate from.</p>

<h3 id="rubypythonandphp">Ruby, Python, and PHP</h3>

<p>Objects in Ruby and Python are hash tables, and have many of the properties of hash tables. Functions and variables can be added to objects at run time.</p>

<p>Monkey C objects are compiled and cannot be modified at runtime. All variables have to be declared before they can be used, either in the local function, the class instance, or in the parent module.</p>

<p>When importing a module, all classes inside the module have to be referenced through their parent module. You import modules, not classes, into your namespace.</p>

<h1 id="objectsmodulesandmemory">Objects, Modules, and Memory</h1>

<p>Objects are created with the <code>class</code> keyword. Classes allow data and operations to be bound together on an object. In Monkey C, variables, functions, and other classes can be defined within a class.</p>

<h2 id="constructors">Constructors</h2>

<p>When an object is instantiated with the <code>new</code> keyword, the memory is allocated and the <code>initialize</code> method is called:</p>

<pre><code class="typescript">class Circle
{
    protected var mRadius;
    public function initialize( aRadius ) {
      mRadius = aRadius;
    }
}

function createCircle() {
    var c = new Circle( 1.5 );
}
</code></pre>

<p>Within a method implementation you can refer to your current instance using either the <code>self</code> or <code>me</code> keywords.</p>

<pre><code class="java">class A
{
    public var x;
    public var y;
    public function initialize() {
        me.x = &quot;Hello&quot;; // Set current instance x variable
        self.y = &quot;Hello&quot;; // Set current instance y variable
    }
}
</code></pre>

<p>To instantiate an inner class of nested classes, you must first instantiate the outer class. However, unlike Java, nested classes in Monkey C do not have access to the members of the enclosing class.</p>

<h2 id="inheritance">Inheritance</h2>

<p>Monkey C uses the <code>extends</code> keyword to support class inheritance:</p>

<pre><code class="typescript">import Toybox.System;

class A
{
    function print() {
        System.print( &quot;Hello!&quot; );
    }
}

class B extends A
{

}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints &quot;Hello!&quot;
}
</code></pre>

<p>You can call superclass methods by using the super class&#8217;s symbol:</p>

<pre><code class="java">import Toybox.System;

class A
{
    function print() {
        System.print( &quot;Hello!&quot; );
    }
}

class B extends A
{
    function print() {
        // Call the super class implementation
        A.print();

        // Amend the output
        System.println( &quot;Hola!&quot; );
    }
}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints &quot;Hello! Hola!&quot;
}
</code></pre>

<h2 id="datahiding">Data Hiding</h2>

<p>Class members have three levels of access &mdash; <code>public</code>, <code>protected</code>, and <code>private</code>.</p>

<p><code>public</code> is the default, but it can also be explicitly specified. When the <code>public</code> access modifier is used for an enum, variable, or function, those members are visible to all other classes.</p>

<p>The <code>private</code> modifier specifies that the member can only be accessed in its own class.</p>

<p>The <code>protected</code> modifier specifies that the member can only be accessed by its own class or one of its subclasses. The <code>hidden</code> keyword is synonymous with the <code>protected</code> keyword.</p>

<pre><code class="typescript">import Toybox.System;

class Foo
{
    public var publicVar;
    protected var _protectedVar
    private var _privateVar;

    public function initialize() {
        publicVar = &quot;a&quot;;
        _protectedVar = &quot;b&quot;;
        _privateVar = &quot;c&quot;;
    }
}

class Bar extends Foo {
    public function initialize() {
        // Initialize the parent
        Foo.initialize();
        publicVar = &quot;b&quot;;
        _protectedVar = &quot;c&quot;;
        // Error - can't access private member
        _privateVar = &quot;d&quot;;
    }
}

function usageSample() {
    var v = new Foo();
    System.println( v.publicVar );
    // Error - cannot access protected member
    System.println( v._protectedVar );
    // Error - cannot access private member
    System.println( v._privateVar );
}
</code></pre>

<h2 id="polymorphism">Polymorphism</h2>

<p>Most object-oriented languages support a concept of <em>polymorphic functions</em> in which a function can have multiple definitions based on the input parameter quantity and type. Partially because of its duck-typed nature, Monkey C does not support this kind of runtime polymorphism.</p>

<p>Because function parameters are duck typed, it is possible to implement some level of polymorphism using the <code>instanceof</code> operator:</p>

<pre><code class="typescript">import Toybox.Lang;

function aPolymorphicFunction(a) {
    switch(a) {
        case instanceof String:
            return doTheStringVersion(a);
        case instanceof Number:
        case instanceof Long:
            return doTheNumericVersion(a);
        default:
            throw new UnexpectedTypeException();
    }

}
</code></pre>

<p>This kind of pattern works when the function expects the same number of inputs. If your function needs to expect multiple inputs, another pattern is to use the options dictionary. You can use symbols to define the keys to maximize processing efficiency:</p>

<pre><code class="typescript">x = aPolymorphicFunction({
    :param1=&gt;&quot;Foo&quot;,
    :param2=&gt;&quot;Bar&quot;
})
</code></pre>

<p>This pattern is good when you want to leave room for an API to expand in the future.</p>

<h2 id="strongandweakreferences">Strong and Weak References</h2>

<p>Monkey C is reference counted, which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly which is important in low memory environments. The kryptonite of reference counting are <em>circular references</em>. A circular reference happens when a cycle is formed in the reference chain. For example, imagine object C references object A, object A references object B, <em>and</em> object B references object A.</p>
<figure>
<img src="resources/programmers-guide/weak-reference-1.png" style="max-width:153px;"  role="presentation" />
</figure>

<p>Now C gets invited to sit at the cool-kid table, so it dereferences A so it can hang out with its <em>real</em> friends.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a></p>
<figure>
<img src="resources/programmers-guide/weak-reference-2.png" style="max-width:153px;" role="presentation" />
</figure>

<p>This forms a roundabout to nowhere. The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other. The memory used by A and B are now unavailable to objects from the cool-kids table.</p>

<p>Sometimes B really does need to reference A. In these cases, you can use a <em>weak reference</em>. A weak reference is an object that keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled.</p>
<figure>
<img src="resources/programmers-guide/weak-reference-3.png" style="max-width:153px;" role="presentation" />
</figure>

<p>To create a weak reference you use the <code>weak()</code> method. Weak is a method in <code>Lang.Object</code> and is available to all Monkey C objects.</p>

<pre><code class="java">// I would make a &quot;Hans and Franz&quot; reference but I
// think certain advertising has made them uncool.
var weakRef = obj.weak()
</code></pre>

<p>If you are calling <code>weak</code> on one of the immutable types (<code>Number</code>, <code>Float</code>, <code>Char</code>, <code>Long</code>, <code>Double</code>, <code>String</code>), then it returns the object itself. Otherwise it will return a <a href="./doc/Toybox/Lang/WeakReference.html"><code>WeakReference</code></a> instance.</p>

<pre><code class="typescript">//! A weak reference is a loosely bound reference to
//! another object. If all strong references have been
//! freed, the get() method will return null.
//! This allows the developer to avoid circular references.
//! @since 1.2.0
class WeakReference
{
    //! Return if the reference is still alive.
    //! @return true if object is still alive, false otherwise.
    //!    When you are dead I will be STILL ALIVE
    //!    I feel fantastic and I am STILL ALIVE
    function stillAlive();

    //! Get the object referenced.
    //! @return Object referenced, or null if object is no
    //!         longer alive.
    function get();
}
</code></pre>

<p>You can use the <code>stillAlive</code> method to check if the reference has been cleaned up. Use <code>get</code> to create a strong reference to the object. Only keep the strong reference during the scope you need it!</p>

<pre><code class="java">// This is a triumph...
if( weakRef.stillAlive() ) {
    var strongRef = weakRef.get();
    strongRef.doTheThing();
}
</code></pre>

<h3 id="handlesandheapallocation">Handles and Heap Allocation</h3>

<p>The heap memory limit varies on a per device basis. Starting with version 2.4.x, Connect IQ uses a dynamically allocated heap for memory handles. Each unique object takes up one memory handle. Object references do not have unique allocations and only reference the memory handle of the object. Older versions of Connect IQ have a smaller, static limit for objects defined by the device. Reaching the object limit in either version will cause a runtime error.</p>

<h2 id="modules">Modules</h2>

<p>Modules in Monkey C allow for the scoping of classes and functions. Unlike Java packages, Monkey C modules have many of the same properties as classes. You can have variables, functions, classes, and other modules at the module level:</p>

<pre><code class="java">module MyModule
{
    class Foo
    {
        var mValue;
    }
    var moduleVariable;
}

function usageSample() {
    MyModule.moduleVariable = new MyModule.Foo();
}
</code></pre>

<p>However, unlike classes in Monkey C, modules have no concept of inheritance or data hiding (the <code>extends</code>, <code>private</code>, and <code>protected</code> keywords are not supported for modules).</p>

<h3 id="importandusingstatements">Import and Using Statements</h3>

<p>You can bring a module into your scoping level with the <code>import</code> keyword. When you use <code>import</code> it will bring the <em>module suffix and all classes in the module into the type namespace</em>. This allows classes in a module to be accessed without the module suffix, making for easier typing. Function invocations still require the module suffix to be accessed.</p>

<pre><code class="typescript">import Toybox.Lang;
import Toybox.System;

// Import lets you say goodbye to
// module prefixes
var globalX as Number or String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = &quot;2&quot;; // Allowed
    // Still require prefixes in code
    System.println(&quot;globalX = &quot; + globalX);
}
</code></pre>

<p>You can also bring a module into your scoping level with the <code>using</code> keyword. <code>using</code> allows a module to be imported into another class or module by a symbol:</p>

<pre><code class="java">using Toybox.System;

function foo() {
    System.print( &quot;Hello&quot; );
}
</code></pre>

<p>The <code>as</code> clause provides a way to assign a module to a different name within scope. This is useful for shortening module names or when you simply disagree with our naming scheme:</p>

<pre><code class="java">using Toybox.System as Sys;

function foo() {
    Sys.print( &quot;Hello&quot; );
}
</code></pre>

<p><code>using</code> statements are scoped to the class or module in which they are defined.</p>

<p>The difference between <code>import</code> and <code>using</code> is subtle. <code>import</code> brings the module name and class names into the namespace, where <code>using</code> only brings the module name into the namespace. If you are using <a href="./LearningMonkeyC.html/#monkeytypes">monkeytypes</a> you should use <code>import</code> exclusively, as it will save you a lot of redundant module references. Finally, the <code>as</code> clause is only supported for <code>using</code> statements.</p>

<h2 id="scoping">Scoping</h2>

<p>Monkey C is a message-passed language. When a function is called, the virtual machine does a look up operation at runtime to find the function being called. Here is the hierarchy that it will search:</p>

<ol>
<li>Instance members of the class</li>
<li>Members of the superclass</li>
<li>Static members of the class</li>
<li>Members of the parent module, and the parent modules up to the global namespace</li>
<li>Members of the superclass&#8217;s parent module up to the global namespace</li>
</ol>

<p>For example, if function <code>a()</code> is called on an instance of <code>Child()</code>, it will be able to access non-member functions <code>b()</code>, <code>c()</code>, and <code>d()</code> when:</p>

<ul>
<li><code>b()</code> is a member of the parent module of the object</li>
<li><code>c()</code> is a static member of the object</li>
<li><code>d()</code> is a member of the parent module of the parent module, also known as the globals module</li>
</ul>

<p>The code below tries to clarify:</p>

<pre><code class="typescript">import Toybox.System;

// A globally visible function
function d() {
    System.print( &quot;this is D!&quot; );
}

module Parent
{
    // A module function.
    function b() {
        System.print( &quot;This is B!&quot; );
        d(); // Call a globally visible function
    }

    // A child class of a Parent module
    class Child
    {
        // An instance method of Child
        function a() {
            System.print( &quot;This is A!&quot; );
            b(); // Call a function in our parent module
            c(); // Call a static function within the class.
            d(); // Call a globally visible function.
        }

        // A static function of Child.
        // Note that static methods can't call instance method but still have
        // access to parent modules.
        static function c() {
            System.print( &quot;This is C!&quot; );
            b(); // Call a method in the parent module.
            d(); // Call a globally visible function
        }
    }
}
</code></pre>

<p>Sometimes you want to run your search from the global namespace instead of your current scope. You can do this using the bling symbol <code>$</code>. The bling symbol refers to global scope:</p>

<pre><code class="java">function helloFunction() {
    System.println(&quot;Hello Hello&quot;);
}

class A {
     function helloFunction() {
        System.println(&quot;Every time I say goodbye you say hello&quot;);
     }

    function b() {
        // Call global helloFunction
        $.helloFunction();
        // Call instance helloFunction
        helloFunction();
    }
}
</code></pre>

<p>If you are referring to a global variable, using bling can improve runtime performance<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a>:</p>

<pre><code class="java">var globalScopedVariable = &quot;Global String&quot;;

module A
{
    class B
    {
        function c() {
            // To find globalScopedVariable, the VM will search at runtime:
            //     instance B
            //     instance B's superclass Toybox.Lang.Object
            //     Module A
            //     Module A's parent globals
            // and finally find globalScopedVariable.
            System.println(globalScopedVariable);
            // This will search only the global namespace for globalScopedVariable.
            // Thanks bling!
            System.println($.globalScopedVariable);
        }
    }
}
</code></pre>

<p>Because Monkey C is dynamically typed, referencing a global variable will search your Object&#8217;s inheritance structure and the module hierarchy before it will eventually find the global variable. Using the bling symbol we can search globals directly.</p>

<h1 id="functions">Functions</h1>

<p>Functions are the meat<a href="#fn:4" id="fnref:4" title="see footnote" class="footnote">[4]</a> of your program. Functions define discrete callable units of code.</p>

<p>Monkey C functions can take arguments, but because Monkey C is a dynamically typed language the argument types is not declared; just its name. Also, it is not necessary to declare the return value of a function, or even if a function returns a value, because all functions return values.</p>

<p>Functions can exist in a class or module, or appear in the global module.</p>

<h2 id="variablesexpressionsandoperators">Variables, Expressions, and Operators</h2>

<p>The basic types supported by Monkey C are:</p>

<ul>
<li><strong>Integers</strong> - 32-bit signed integers</li>
<li><strong>Floats</strong> - 32-bit floating point numbers</li>
<li><strong>Longs</strong> – 64-bit signed integers</li>
<li><strong>Doubles</strong> – 64-bit floating point numbers</li>
<li><strong>Booleans</strong> - <code>true</code> and <code>false</code></li>
<li><strong>Chars</strong> - Unicode characters</li>
<li><strong>Strings</strong> - strings of characters</li>
<li><strong>Objects</strong> – Instantiated objects (defined with the class keyword)</li>
<li><strong>Arrays</strong> - Allocated with the syntax <code>new [X]</code> where &#8216;X&#8217; is an expression computing the size of the array</li>
<li><strong>Dictionaries</strong> - Associative arrays, allocated with the syntax <code>{}</code></li>
</ul>

<h3 id="keywords">Keywords</h3>

<p>Here is a list of keywords in the Monkey C programming language. You cannot use any of the following as variables or symbols in your programs. The keywords <code>native</code> and <code>alias</code> are reserved, even though it is not currently used. <code>true</code>, <code>false</code>, <code>null</code>, <code>NaN</code>, <code>new</code>, <code>and</code>, and <code>or</code> might seem like keywords, but they are actually literals and operators; you cannot use them as identifiers in your programs.</p>
<div id="test">

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<tbody>
<tr>
	<td style="text-align:center;"><code>as</code></td>
	<td style="text-align:center;"><code>const</code></td>
	<td style="text-align:center;"><code>enum</code></td>
	<td style="text-align:center;"><code>has</code></td>
	<td style="text-align:center;"><code>module</code></td>
	<td style="text-align:center;"><code>self</code></td>
	<td style="text-align:center;"><code>using</code></td>
</tr>
<tr>
	<td style="text-align:center;"><code>break</code></td>
	<td style="text-align:center;"><code>continue</code></td>
	<td style="text-align:center;"><code>extends</code></td>
	<td style="text-align:center;"><code>hidden</code></td>
	<td style="text-align:center;"><code>private</code></td>
	<td style="text-align:center;"><code>static</code></td>
	<td style="text-align:center;"><code>var</code></td>
</tr>
<tr>
	<td style="text-align:center;">`<code>case</code></td>
	<td style="text-align:center;"><code>default</code></td>
	<td style="text-align:center;"><code>finally</code></td>
	<td style="text-align:center;"><code>if</code></td>
	<td style="text-align:center;"><code>protected</code></td>
	<td style="text-align:center;"><code>switch</code></td>
	<td style="text-align:center;"><code>while</code></td>
</tr>
<tr>
	<td style="text-align:center;"><code>catch</code></td>
	<td style="text-align:center;"><code>do</code></td>
	<td style="text-align:center;"><code>for</code></td>
	<td style="text-align:center;"><code>instanceof</code></td>
	<td style="text-align:center;"><code>public</code></td>
	<td style="text-align:center;"><code>throw</code></td>
</tr>
<tr>
	<td style="text-align:center;"><code>class</code></td>
	<td style="text-align:center;"><code>else</code></td>
	<td style="text-align:center;"><code>function</code></td>
	<td style="text-align:center;"><code>me</code></td>
	<td style="text-align:center;"><code>return</code></td>
	<td style="text-align:center;"><code>try</code></td>
</tr>
</tbody>
</table>
</div>

<h3 id="declaringvariables">Declaring Variables</h3>

<p>All local variables must be declared ahead of time using the <code>var</code> keyword. In the Monkey C language, all values (including numeric values) are objects.</p>

<pre><code class="java">var n = null;               // Null reference
var x = 5;                  // 32-bit signed integers
var y = 6.0;                // 32-bit floating point
var l = 5l;                 // 64-bit signed integers
var d = 4.0d;               // 64-bit floating point
var bool = true;            // Boolean (true or false)
var c = 'x';                // Unicode character
var str = &quot;Hello&quot;;          // String
var arr = new [20 + 30];    // Array of size 50
var dict = { x=&gt;y };        // Dictionary: key is 5, value is 6.0
var z = arr[2] + x;         // Null pointer waiting to happen
</code></pre>

<p>Monkey C supports the following operators:</p>
<div id="operators">

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;">Precedence</th>
	<th style="text-align:center;">Operator</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">1</td>
	<td style="text-align:center;"><code>new</code></td>
	<td style="text-align:left;">creation</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>!</code></td>
	<td style="text-align:left;">logical NOT</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>~</code></td>
	<td style="text-align:left;">bitwise NOT</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>( )</code></td>
	<td style="text-align:left;">function invocation</td>
</tr>
<tr>
	<td style="text-align:center;">2</td>
	<td style="text-align:center;"><code>*</code></td>
	<td style="text-align:left;">multiplication</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>/</code></td>
	<td style="text-align:left;">division</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>%</code></td>
	<td style="text-align:left;">modulo</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&amp;</code></td>
	<td style="text-align:left;">bitwise AND</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&lt;&lt;</code></td>
	<td style="text-align:left;">left shift</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;&gt;</code></td>
	<td style="text-align:left;">right shift</td>
</tr>
<tr>
	<td style="text-align:center;">3</td>
	<td style="text-align:center;"><code>+</code></td>
	<td style="text-align:left;">addition</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>-</code></td>
	<td style="text-align:left;">subtraction</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>|</code></td>
	<td style="text-align:left;">bitwise OR</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>^</code></td>
	<td style="text-align:left;">bitwise XOR</td>
</tr>
<tr>
	<td style="text-align:center;">4</td>
	<td style="text-align:center;"><code>&lt;</code></td>
	<td style="text-align:left;">less than</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&lt;=</code></td>
	<td style="text-align:left;">less than or equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;</code></td>
	<td style="text-align:left;">greater than</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>&gt;=</code></td>
	<td style="text-align:left;">greater than or equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>==</code></td>
	<td style="text-align:left;">equals</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>!=</code></td>
	<td style="text-align:left;">not equals</td>
</tr>
<tr>
	<td style="text-align:center;">5</td>
	<td style="text-align:center;"><code>&amp;&amp;</code></td>
	<td style="text-align:left;">logical AND</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>and</code></td>
	<td style="text-align:left;"></td>
</tr>
<tr>
	<td style="text-align:center;">6</td>
	<td style="text-align:center;"><code>||</code></td>
	<td style="text-align:left;">logical OR</td>
</tr>
<tr>
	<td style="text-align:center;"></td>
	<td style="text-align:center;"><code>or</code></td>
	<td style="text-align:left;"></td>
</tr>
<tr>
	<td style="text-align:center;">7</td>
	<td style="text-align:center;"><code>?:</code></td>
	<td style="text-align:left;">conditional</td>
</tr>
</tbody>
</table>
</div>

<h3 id="symbols">Symbols</h3>

<p>Symbols are lightweight constant identifiers. When the Monkey C compiler finds a new symbol, it will assign it a new unique value. This allows symbols to be used as keys or constants without explicitly declaring a const or enum:</p>

<pre><code class="java">var a = :symbol_1;
var b = :symbol_1;
var c = :symbol_2;
Sys.println( a == b );  // Prints true
Sys.println( a == c );  // Prints false
</code></pre>

<p>Symbols can be useful when wanting to create keys without having to declare an enum:</p>

<pre><code class="java">var person = { :firstName=&gt;&quot;Bob&quot;, :lastName=&gt;&quot;Jones&quot; };
</code></pre>

<h3 id="constants">Constants</h3>

<p>Constants are named, immutable values declared with the <code>const</code> keyword. These are useful for storing unchanging values that may be used repeatedly throughout code. Constants must be declared at the module or class level; they cannot be declared within a function.</p>

<p>Constants support the same types as <a href="#declaringvariables">listed for variables</a>. It is important to note that with data structures like arrays, <code>const</code> functions similar to Java&#8217;s <code>final</code> keyword. For example, a <code>const</code> array prevents the array from being replaced by a new instance, but the elements of the array may be modified.</p>

<pre><code class="java">const PI = 3.14;
const EAT_BANANAS = true;
const BANANA_YELLOW = &quot;#FFE135&quot;;
</code></pre>

<h3 id="enumerations">Enumerations</h3>

<p>Enumerations are explicit or auto-incrementing constant mappings from symbol to integer. Unless explicity set (see the second example), each proceeding symbol is automatically assigned the value of its predecessor plus one, starting with <code>0</code>. So, in the following example, the symbol Monday is automatically assigned the value <code>0</code>, Tuesday is assigned <code>1</code>, and so on. These symbols can be used just like constant variables (which is essentially what they are). Enums must be declared at the module or class level; they cannot be declared within a function.</p>

<pre><code class="java">enum {
    Monday,   // Monday = 0
    Tuesday,  // Tuesday = 1
    Wednesday // Wednesday = 2
    // ...and so on
}
</code></pre>

<pre><code class="java">enum {
    x = 1337, // x = 1337
    y,        // y = 1338
    z,        // z = 1339
    a = 0,    // a = 0
    b,        // b = 1
    c         // c = 2
}
</code></pre>

<h3 id="callingmethodsandfunctions">Calling Methods and Functions</h3>

<p>To call a method within your own class or module, simply use the function call syntax:</p>

<pre><code class="typescript">function foo( a ) {
    //Assume foo does something really impressive
}

function bar() {
    foo( &quot;hello&quot; );
}
</code></pre>

<p>If calling on an instance of an object, precede the call with the object and a &#8216;<code>.</code>&#8217;.</p>

<p>When accessing class members, <code>public</code> and <code>protected</code> variables should be accessed using either one of the following formats:</p>

<pre><code class="typescript">var x = mMemberVariable;
var y = self.mMemberVariable;
</code></pre>

<p>Overridden parent member functions should be accessed using the following syntax:</p>

<pre><code class="typescript">class A
{
    function overridableMethod() {
        System.println(&quot;I am A!&quot;);
    }
}

class B extends A
{
    function overridableMethod() {
        System.println(&quot;B wins!&quot;);
        A.overridableMethod();
    }
}
</code></pre>

<p>The syntax of <code>SuperClass.memberVariable</code> is not supported in the Monkey C language. Always use <code>self</code> to access member variables of super classes.</p>

<h3 id="ifstatements">If Statements</h3>

<p><code>if</code> statements allow branch points in your code:</p>

<pre><code class="java">myInstance.methodToCall( parameter );

if ( a == true ) {
    // Do something
} else if ( b == true ) {
    // Do something else
} else {
    // If all else fails
}

// Monkey C also supports the ternary operator
var result = a ? 1 : 2;
</code></pre>

<p>The expression inside the <code>if</code> statement is required to be an expression; assignments are not allowed. Things that will evaluate to true are:</p>

<ul>
<li><code>true</code></li>
<li>A non-zero integer</li>
<li>A non-null object</li>
</ul>

<h3 id="switchstatements">Switch Statements</h3>

<p>Like <code>if</code> statements, <code>switch</code> statements also allow branch points in your code. Deciding whether to use <code>if</code> statements or a <code>switch</code> statement is based on readability and the expression that the statement is testing.</p>

<p>A <code>switch</code> statement tests expressions based only on a single object. Like <code>if</code> statements, the expression inside the <code>switch</code> statement is required to be an expression; assignments are not allowed. You can have any number of <code>case</code> statements within a <code>switch</code> statement. Each <code>case</code> is followed by the object or <code>instanceof</code> object to be compared to and a colon:</p>

<pre><code class="typescript">switch ( obj ) {
    case true:
    // Do something
    break;
    case 1:
    // Do something
    break;
    case &quot;B&quot;: {
        // Do something
        break;
    }
    // Executed based on the type
    // instead of the value
    case instanceof MyClass:
    // Do something
    break;
    default:
    // If all else fails
    break;
}

// Monkey C also supports fall-through into the next case statement
switch ( obj ) {
    case false:
    // Do something
    // Fall through and execute the code in the next case block
    case 2: {
        // Do something
        break;
    }
    case instanceof MyOtherClass:
    // Do something
    break;
    case &quot;B&quot;:
    // Do something
    // Fall through and execute the code in the default block
    default:
    // If all else fails
    break;
}
</code></pre>

<p>The <code>instanceof</code> operator is discussed in more detail later in this guide.</p>

<p>When the object being switched on is either equal to or an instance of the value defined in a <code>case</code> statement, the statements following that <code>case</code> will execute until a <code>break</code> statement is reached. Each <code>break</code> statement terminates the enclosing <code>switch</code> statement. Without a <code>break</code> statement, <code>case</code> statements fall through: all statements after the matching <code>case</code> label are executed in sequence, regardless of the expression of the subsequent <code>case</code> labels, until a <code>break</code> statement is encountered. A final <code>break</code> statement is not required because control flow will just naturally fall out of the <code>switch</code> statement.</p>

<p>A <code>switch</code> statement can also have a single optional <code>default</code> case, which is not required to appear at the end of the <code>switch</code> statement. The <code>default</code> case handles all objects that are not explicitly handled by one of the <code>case</code> statements.</p>

<h3 id="switchblockvariablescoping">Switch Block Variable Scoping</h3>

<p>The body of a <code>switch</code> statement is known as the &#8220;switch block&#8221;. Variables declared within the switch block will be scoped at the switch block level. Variables defined within curly braces of a case block will be scoped at that code block level. Additionally, due to the nature of fall-through cases, all variables defined at the switch block level must be initialized before being used in any subsequent <code>case</code> statements. For instance:</p>

<pre><code class="java">switch ( obj ) {
    case true:
    var aaa = 1; // Scoped at the switch block level
    ...
    case 1:
    var zzz = aaa; // Results in a compiler error because aaa was not initialized in this case block
    ...
    break;
    case &quot;B&quot;: {
       var aaa = true; // Scoped at the code block level within the curly braces, no scoping conflict with variable aaa at the swtich block level
       ...
       break;
    }
    case instanceof MyClass:
    var aaa = &quot;Hello!&quot; // Results in a compiler error because aaa has already been defined in the switch block
    ...
    default:
    aaa = 0; // aaa was defined in the first case and initialized at the beginning of the default case, no errors!
    var good = aaa;
    ...
    break;
}
</code></pre>

<h3 id="loops">Loops</h3>

<p>Monkey C supports <code>for</code> loops, <code>while</code> loops, and <code>do/while</code> loops. <code>while</code> and <code>do/while</code> loops have a familiar syntax:</p>

<pre><code class="java">// do/while loop
do {
    // Code to do in a loop
}
while( expression );

// while loop
while( expression ) {
    // Code to do in a loop
}
</code></pre>

<p>Loops must have braces around them because single-line loops are not supported:</p>

<pre><code class="java">// Monkey C does allow for variable declaration in for loops
for( var i = 0; i &lt; array.size(); i++ ) {
    // Code to do in a loop
}
</code></pre>

<p>Control within loops can be managed by using the <code>break</code> and <code>continue</code> statements. These should also have familiar behavior:</p>

<pre><code class="java">// This for loop should only print 5, 6, and 7.
for (var i = 0; i &lt; 10; i += 1) {
    if (i &lt; 5) {
        continue;
    }
    System.println(i);
    if (7 == i) {
        break;
    }
}
</code></pre>

<h3 id="returningvaluesfromfunctions">Returning Values From Functions</h3>

<p>All functions return values in Monkey C. You can explicitly set the return value by using the <code>return</code> keyword:</p>

<pre><code class="java">return expression;
</code></pre>

<p>The expression is optional. Functions without a return statement automatically return the last value operated on.</p>

<h3 id="instanceofandhas">Instanceof and Has</h3>

<p>As a duck-typed language, Monkey C gives the programmer great flexibility, but the trade off is that the compiler cannot perform the type checking like in C, C++ or Java. Monkey C provides two tools to do runtime type checking&mdash;<code>instanceof</code> and <code>has</code>.</p>

<p>The <code>instanceof</code> operator offers the ability to check if an object instance inherits from a given class. The second argument is the class name to check against:</p>

<pre><code class="java">var value = 5;
// Check to see if value is a number
if ( value instanceof Toybox.Lang.Number )
{
    System.println( &quot;Value is a number&quot; );
}
</code></pre>

<p>The <code>has</code> operator lets you check if a given object has a symbol, which may be a public method, instance variable, or even a class definition or module. The second argument is the symbol to check for. For example, assume we have magnetometer libraries in <code>Toybox.Sensor.Magnetometer</code>, but not all products have a magnetometer. Here is an example of changing your implementation based on those criteria:</p>

<pre><code class="java">var impl;
// Check to see if the Magnetometer module exists in Toybox
if ( Toybox has :Magnetometer )
{
    impl = new ImplementationWithMagnetometer();
}
else
{
    impl = new ImplementationWithoutMagnetometer();
}
</code></pre>

<p>Monkey C&#8217;s object-oriented design patterns in conjunction with the <code>has</code> and <code>instanceof</code> operator enables software that has implementations for many devices in one code base.</p>

<h2 id="callbacks">Callbacks</h2>

<p>Functions in Monkey C are not first class, meaning you cannot pass them as objects directly for use in other functions. However, using the <code>method()</code> function inherited from <code>Toybox.Lang.Object</code>, a class instance can create a <code>Method</code> object, which provides a way to invoke it as a callback method.</p>

<pre><code class="java">class Foo
{
    function operation(a, b) {
        // The code here is really amazing. Like mind blowing amazing. You wish this method was in your program.
    }
}
function usageSample() {
    // Create a new instance of Foo
    var v = new Foo();
    // Get the callback for the operation method from the instance of Foo.
    var m = v.method(:operation);
    // Invoke v's operation method.
    m.invoke(1,2);
}
</code></pre>

<p>A<code>Method</code> object will invoke a method on the instance of the object it came from. It keeps a strong reference to the source object.</p>

<p>Unlike classes, Modules do not inherit from Object so do not have access to the <code>method()</code> function. However, a new instance of <code>Method</code> can be created, which allows module-level functions to be invoked as callbacks in a similar fashion:</p>

<pre><code class="typescript">import Toybox.Lang;

module Foo
{
    function operation() {
        // Do something
    }
}
function moduleSample() {
    var v = new Method(Foo, :operation);
    v.invoke();
}
</code></pre>

<h1 id="containers">Containers</h1>

<p>Monkey C has two container types built into the language: Arrays and Dictionaries.</p>

<h2 id="arrays">Arrays</h2>

<p>Arrays in Monkey C, like variables, are typeless, it is not necessary to declare a data type. There are two forms for creating a new array. To create an empty array of a fixed <code>size</code>, use this:</p>

<pre><code class="typescript">// Create a typeless array
var untypedArray = new [size];
// Create a typed array
var typedArray = new Array&lt;Number&gt;[size];
</code></pre>

<p>To pre-initialize an array, this syntax can be used:</p>

<pre><code class="typescript">// New array. Will be typed as a Tuple
// [Number, Number, Number, Number, Number]
var untypedArray = [1, 2, 3, 4, 5];
// New typed array
var typedArray = [1, 2, 3, 4, 5] as Array&lt;Number&gt;;
</code></pre>

<p>Elements are expressions, so multidimensional arrays can be created using this syntax:</p>

<pre><code class="typescript">var array = [ [1,2], [3,4] ];
</code></pre>

<p>Monkey C does not have a direct way of creating an empty two-dimensional array, one may be initialized with this syntax:</p>

<pre><code class="typescript">// Shout out to all the Java programmers in the house
var array = new [first_dimension_size];

// Initialize the sub-arrays
for( var i = 0; i &lt; first_dimension_size; i += 1 ) {
    array[i] = new [second_dimension_size];
}
</code></pre>

<h2 id="dictionaries">Dictionaries</h2>

<p>Dictionaries, or associative arrays, are a built-in data structure in Monkey C:</p>

<pre><code class="java">var dict = { &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2 };  // Creates a dictionary
System.println( dict[&quot;a&quot;] );        // Prints &quot;1&quot;
System.println( dict[&quot;b&quot;] );        // Prints &quot;2&quot;
System.println( dict[&quot;c&quot;] );        // Prints &quot;null&quot;
</code></pre>

<p>To initialize an empty dictionary, use the following syntax:</p>

<pre><code class="typescript">var x = {};                         // Empty dictionary
</code></pre>

<p>A type suffix can be added when creating new <a href="./doc/Toybox/Lang/Dictionary.html"><code>Dictionary</code></a> objects:</p>

<pre><code class="typescript">var x = {} as Dictionary&lt;Symbol, String&gt;;
// Valid
x[:option] = &quot;value&quot;;
// Invalid
x[&quot;option&quot;] = &quot;value&quot;;
</code></pre>

<p>By default, objects hash on their reference value. Classes should override the <code>hashCode()</code> method in <code>Toybox.Lang.Object</code> to change the hashing function for their type:</p>

<pre><code class="java">class Person
{
    // Return a number as the hash code. Remember that the hash code must be
    // the same for two objects that are equal.
    // @return Hash code value
    function hashCode() {
        // Using the unique person id for the hash code
        return mPersonId;
    }
}
</code></pre>

<p>Dictionaries automatically resize and rehash as the contents grow or shrink. This makes them extremely flexible, but it comes at a cost. Insertion and removal of the contents can cause performance problems if there is accidental or excessive resizing and rehashing. Also, because hash tables require extra space for allocation, they are not as space-efficient as either objects or arrays.</p>

<h1 id="monkeytypes">Monkey Types</h1>

<p>Monkey Types is the gradual type system for the Monkey C language. The type system is designed to recognize Monkey C&#8217;s historically duck-typed nature but add the necessary components to type check your applications at compile time.</p>

<p>Monkey Types has the following goals:</p>

<ol>
<li><strong>Compatibility</strong> - Breaking changes to the Monkey C language would require rework to thousands of Connect IQ apps. Monkey Types extends the Monkey C grammar but avoids breaking changes. Monkey Types is also designed to not rely on additional run time information. Because of this, you can use Monkey Types for apps that run on all Connect IQ compatible devices.</li>
<li><strong>Ease of Use</strong> - The philosophy of Monkey C is to be <em>the language you didn&#8217;t know you already knew</em>. We want the experience of writing Monkey C to be like deja-vu. Likewise, Monkey Types borrows heavily from Kotlin, Swift, and Typescript in its design.</li>
<li><strong>Flexibility</strong> - Monkey Types is a gradual type system. You can leave the type scaffolding off if you choose, or you can strictly type your app.</li>
</ol>

<p>The Connect IQ type checker is disabled by default and is enabled with the <code>-l</code> compiler option. There are four levels of type checking:</p>

<table>
<colgroup>
<col/>
<col/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th>Option</th>
	<th>Level</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>-l 0</code></td>
	<td>Silent</td>
	<td style="text-align:left;">No type checking; keep everything dynamically typed</td>
</tr>
<tr>
	<td><code>-l 1</code></td>
	<td>Gradual</td>
	<td style="text-align:left;">Type check any statement where typing can be inferred, otherwise stay silent</td>
</tr>
<tr>
	<td><code>-l 2</code></td>
	<td>Informative</td>
	<td style="text-align:left;">Type check only what has been typed, warn about ambiguity</td>
</tr>
<tr>
	<td><code>-l 3</code></td>
	<td>Strict</td>
	<td style="text-align:left;">Do not allow compiler ambiguity</td>
</tr>
</tbody>
</table>

<p>Let&#8217;s cover the new syntax available for communicating type information to the type system.</p>

<h2 id="theasclause">The as Clause</h2>

<p>Monkey Types introduces a new keyword <code>as</code>. You use <code>as</code> to bind a type to a member variable, module variable, function argument, or function return value. Locals are always type inferred at assignment.</p>

<p>Once a type has been bound to a value, the compiler will only allow values of that type to be assigned.</p>

<pre><code class="typescript">using Toybox.Lang;
using Toybox.System;

var globalX as Lang.Number = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = &quot;2&quot;; // Not allowed
    System.println(&quot;globalX = &quot; + globalX);
}
</code></pre>

<p>In this example we are declaring that global variable <code>globalX</code> will only accept values of <code>Toybox.Lang.Number</code>. Once that has been declared, the compiler will only allow values of that type to be assigned to <code>globalX</code>.</p>

<p>Since Monkey C is a duck-typed language, only allowing a single type to be bound to a variable would be overly restrictive. An <code>as</code> clause is allowed to have an <code>or</code> clause attached if a variable accepts multiple types.</p>

<pre><code class="typescript">using Toybox.Lang;
using Toybox.System;

var globalX as Lang.Number or Lang.String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = &quot;2&quot;; // Allowed
    System.println(&quot;globalX = &quot; + globalX);
}
</code></pre>

<h2 id="theimportstatement">The import Statement</h2>

<p>In traditional Monkey C, the <code>using</code> statement brings a <code>module</code> suffix into the namespace of the file being processed. To access any functions, variables, or class definitions, the module suffix must be referenced.</p>

<p>For adding type information, all that module prefixing is annoying. Monkey Types introduces the <code>import</code> statement. When you use <code>import</code> it will bring the <em>module suffix and all classes in the module into the type namespace</em>. This allows classes in a module to be accessed without the module suffix, making for easier typing. Functions still require the module suffix to be accessed.</p>

<pre><code class="typescript">import Toybox.Lang;
import Toybox.System;

// Import lets you say goodbye to
// module prefixes
var globalX as Number or String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = &quot;2&quot;; // Allowed
    // Still require prefixes in code
    System.println(&quot;globalX = &quot; + globalX);
}
</code></pre>

<p>Note <code>import</code> does not support using <code>as</code> for renaming modules in a source file<a href="#fn:5" id="fnref:5" title="see footnote" class="footnote">[5]</a>.</p>

<h2 id="namedversusanonymoustypes">Named Versus Anonymous Types</h2>

<p>As you can see from the above example, the type system can allow for complicated type definitions. There are times where a type pattern is repeated that you just want to refer to it by a name.</p>

<p>A <code>typedef</code> statement allows you to create a <em>named type</em> in the application namespace. For example, the following would create a poly type named <code>Numeric</code> in the global namespace. The function <code>add</code> then binds <code>Numeric</code> to parameters <code>a</code> and <code>b</code> and its return value by having the <code>as</code> clauses refer to the <code>Numeric</code> type declaration.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef Numeric as Number or Float or Long or Double;

function add(a as Numeric, b as Numeric) as Numeric {
    return a + b;
}
</code></pre>

<p>If you do not wish to name your type declarations, you can always use the <code>as</code> clause to build the type declaration in line as an anonymous type.</p>

<h2 id="types">Types</h2>

<p>Monkey Types allows you to add a layer of type scaffolding to your Monkey C code. The type system allows for a lot more than associating variables with classes.</p>

<p>This section will overview the type declarations you can use.</p>

<h3 id="any">Any</h3>

<p>Any variable, function argument, or function return value that does not have a type bound to it is of type Any. The Any type can be anything, including nothing. Values of type Any follow the traditional duck type rules of Monkey C.</p>

<p>To bind Any to a value, simply do not add an <code>as</code> clause to it&#8217;s declaration. There is no keyword to bind Any to a value.</p>

<h3 id="void">Void</h3>

<p>The void type is only for return values, and communicates that a function does not allow return values. It also communicates that a function should not expect a return value by calling this function.</p>

<pre><code class="typescript">import Toybox.Lang;

function doNothing() as Void {
    // Compiler error - this is failing to
    // do nothing.
    return true;
}

function doSomething() as String {
    // Compiler error - cannot assign value
    // from a function that returns nothing
    var x = doNothing();
    // Compiler error - doSomething should
    // return a String
}
</code></pre>

<h3 id="concrete">Concrete</h3>

<p>Concrete types are a single reference to a declared class in the program namespace. This is the most traditional and most familiar use of typing. If a value is bound to a concrete type, it will only accept values of that class or any derived classes.</p>

<pre><code class="typescript">import Toybox.Lang;
import WoolMarket;

class Wool {
    public var bagsFull;

    public function initialize(bags as Number) {
        bagsFull = bags;
    }
}

class Sheep {
    public var wool as Wool;

    public function initialize() {
        wool = new Wool(1);
    }
}

class BlackSheep extends Sheep {
    public function initialize() {
        Sheep.initialize();
        wool = new Wool(3);
    }
}

function processSheep(baa as Sheep) {
    if(baa.wool != null) {
        WoolMarket.sellWool(baa.wool);
    }
}

function example() {
    // Allowed
    processSheep(new Sheep());
    processSheep(new BlackSheep());
    // Not allowed
    processSheep(new Wool());
}
</code></pre>

<p>Note that concrete types do not implicitly accept <code>null</code> as a value. If you want a value to also accept <code>null</code> you must make a poly type (see <a href="#null"><code>Null</code></a> for more information).</p>

<h3 id="poly">Poly</h3>

<p>Poly types allow the concatenation of multiple types into a single type. This allows for the type system to model the duck-type nature of Monkey C. To create a poly type, you simply use the <code>or</code> clause when defining your type.</p>

<p>A poly type will accept:</p>

<ol>
<li>A value whose type is bound to one of the types within the poly type</li>
<li>A value bound to a poly type whose types are within the definition of the destination type</li>
</ol>

<pre><code class="typescript">import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;
typedef Numeric as Number or Float or Long or Double;

function add(a as Addable, b as Addable) as Addable {
    return a + b;
}

function subtract(a as Numeric, b as Numeric) as Numeric {
    return a - b;
}

function doWork() {
    // Allowed
    var x as Addable = add(&quot;1&quot;, &quot;2&quot;);
    // Not allowed; Addable has String which is
    // not within Numeric
    var y as Numeric = subtract(x, 2);
}
</code></pre>

<h3 id="interface">Interface</h3>

<p>An interface type requires a class to contain a set of member declarations. The members can be member variables and functions.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef LittleBoys as interface {
    var frogs as Array&lt;Frogs&gt;;
    var snails as Array&lt;Snails&gt;;
    var puppyDogTails as Array&lt;PuppyDogTails&gt;;
};

// Implements LittleBoys interface
class MaleChild {
    var frogs as Array&lt;Frogs&gt;;
    var snails as Array&lt;Snails&gt;;
    var puppyDogTails as Array&lt;PuppyDogTails&gt;;
}
</code></pre>

<p>Note that the class does not require additional decoration to implement the interface. This allows anonymous interfaces to be defined within function arguments.</p>

<pre><code class="typescript">// Processing
function example(you as interface {
    var frogs as Array&lt;Frogs&gt;;
})
</code></pre>

<h3 id="container">Container</h3>

<p>The Monkey C language has two native container types, <code>Array</code> and <code>Dictionary</code>. While the Monkey Types system does not support generics, it does allow for the developer to type the value type of an <code>Array</code> or the key and value type of a <code>Dictionary</code>.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef ContainerA as Array&lt;Number&gt;;
typedef ContainerB as Dictionary&lt;String, Number&gt;;
</code></pre>

<p>Container types only match other container types if both the key and value types are equivalent. An <code>Array&lt;String&gt;</code> only matches an <code>Array&lt;String&gt;</code> and not an <code>Array&lt;String or Number&gt;</code>.</p>

<p>Monkey C does not infer container types at this time, so you will need to declare your containers. If you want to create a new typed array or dictionary you can use the following syntax:</p>

<pre><code class="typescript">class ContainerClass {
    // Array of 10 items that takes only numbers
    var typedArray as Array&lt;Number&gt; = new Array&lt;Number&gt;[10];
    // Initialized array
    var initializedArray as Array&lt;Number&gt; = [1, 2, 3, 4, 5] as Array&lt;Number&gt;;
    // Initialized dictionary
    var initializedDictionary as Dictionary&lt;String, String&gt; = {&quot;this&quot;=&gt;&quot;that&quot;} as Dictionary&lt;String, String&gt;;
}
</code></pre>

<h3 id="tuples">Tuples</h3>

<p>A common pattern in Monkey C is to use arrays as structured groupings. Monkey types allows modeling an array by binding the indexed items to types.</p>

<p>Think of Tuple types like Dictionary types, except the key is implied by the order. In the following example, the array being returned is automatically typed as a Tuple of types <code>[ StartView, StartDelegate]</code>. This is typed against the allowed return value [Views, InputDelegates] and found to match:</p>

<pre><code class="typescript">function getInitialView() as [Views] or [Views, InputDelegates] {
    return [ new StartView(), new StartDelegate() ] ;
}
</code></pre>

<p>The rules of Tuple type A matching Tuple type B are as follows:</p>

<ul>
<li>Tuple A and B must be the same length</li>
<li>For every index, every type in A must be an instance of B</li>
</ul>

<p>Arrays created with the <code>[ value, value...]</code> syntax will now be typed as a Tuple instead of an <code>Array&lt;Any&gt;</code>. You can use Container types if that better matches the pattern you are implementing, but Tuples have a natural compatibility with Container types. Tuples of type <code>[A, B, C]</code> shall be instance of <code>Array&lt;A or B or C&gt;</code> if the types A, B, and C are in the polytype definition of the container type.</p>

<pre><code class="typescript">function sumArray(x as Array&lt;Numeric&gt;) as Number {
    var result = 0;
    for (var i = 0; i &lt; x.size(); i++) {
        result += x[i];
    }
    return result;
}

function sumThisTuple() as Number{
    // This should pass type checking because the
    // Tuple [Number, Number... ] should be an instanceOf Array&lt;Numeric&gt;
    return sumArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
}

</code></pre>

<p>Tuple types are also more mutable. As the underlying array changes, they are modified as long as the type system can keep up. The type system will not track changes to the tuple&#8217;s types when passed as an argument to another method.</p>

<pre><code class="typescript">function foo(x as [Number, Number, Number]) as [Number, Number, Number] {
    x[1] = &quot;Hello&quot;; // Allowed, type is now [Number, String, Number]
    return x; // Error, type mismatch
}
</code></pre>

<h3 id="dictionary">Dictionary</h3>

<p>A common pattern in Monkey C is to use an options dictionary as an argument. This allows for extensible APIs. Monkey Types allows modeling an options dictionary by binding key literals to types.</p>

<pre><code class="typescript">import Toybox.Lang;

function doWork(options as {
    :option1 as String,
    :option2 as {
        &quot;name&quot; as String,
        &quot;value&quot; as Number
    }
})
</code></pre>

<p>If a dictionary is declared inline, the compiler will track the types bound to the values, and then type check to see if all the value types match. It will not require all keys to be provided, and it will not error if additional keys are added.</p>

<pre><code class="typescript">doWork({:option1=&gt;&quot;x&quot;, :option3=&gt;true})
</code></pre>

<h3 id="enumerations-1">Enumerations</h3>

<p>Enumerations can now be named types by appending a name to the declaration. Enumeration values will be bound to both their enumeration type as well as their value type.</p>

<pre><code class="typescript">import Toybox.Lang;

enum Dog {
    SPOT = &quot;Spot&quot;,
    LUKE = &quot;Luke&quot;,
    POCO = &quot;Poco&quot;,
    COMMODORE = &quot;Commodore&quot;,
    BINGO = &quot;B_I_N_G_O&quot;
}

function getDogName(dog as Dog) as String {
    // Return the dog name
    return dog.toString();
}
</code></pre>

<h3 id="callback">Callback</h3>

<p>The base object of Monkey C contains the <code>method</code> method to create <code>Method</code> callback objects<a href="#fn:6" id="fnref:6" title="see footnote" class="footnote">[6]</a>. The callback type allows you to type <code>Method</code> objects based on what the expected parameters and return values are.</p>

<pre><code class="typescript">import Toybox.Lang;

function doWork(
    x as Method(a as Number) as String
) as String {
    return x.invoke(2);
}
</code></pre>

<h3 id="null">Null</h3>

<p>Monkey Types treats Null as its own unique type. More importantly, Monkey Types requires explicit declaration if <code>null</code> is an allowed value.</p>

<pre><code class="typescript">function doWork() as Number or Null
</code></pre>

<p>The <code>?</code> can be used with single type declarations to make it a null accepting poly type.</p>

<pre><code class="typescript">function doWork() as Number?
</code></pre>

<h2 id="typematchingandambiguity">Type Matching and Ambiguity</h2>

<p>Because of the duck type nature of Monkey C, ambiguity is inherit to Monkey Types. Ideally, type systems would have very clear rules for if a type does or doesn&#8217;t match, but Monkey Types has True, False, and Maybe<a href="#fn:7" id="fnref:7" title="see footnote" class="footnote">[7]</a>.</p>

<p>Assuming we have the following:</p>

<pre><code class="type">var a as A;
var b as B;

a = b; // Is this assigment allowed?
</code></pre>

<p>You can use the following table</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>A↓ B→</th>
	<th>Any</th>
	<th>Concrete</th>
	<th>Poly</th>
	<th>Interface</th>
	<th>Container</th>
	<th>Dictionary</th>
	<th>Enum</th>
	<th>Callback</th>
	<th>Null</th>
</tr>
</thead>

<tbody>
<tr>
	<td><strong>Any</strong></td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
	<td>True</td>
</tr>
<tr>
	<td><strong>Concrete</strong></td>
	<td>Maybe</td>
	<td>True if B is or extends A</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>Maybe if A is a Dictionary or Array</td>
	<td>Maybe if A is a Dictionary, False otherwise</td>
	<td>True if enum value type matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Poly</strong></td>
	<td>Maybe</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if all references exist in both A and B. Maybe if there are some types in B not in A. False if no matching types between B and A</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
	<td>True if B is a type within A, False otherwise</td>
</tr>
<tr>
	<td><strong>Interface</strong></td>
	<td>Maybe</td>
	<td>True if B is an object that contains all members of interface A, False otherwise</td>
	<td>Maybe if the poly contains a matching type</td>
	<td>True if B&#8217;s interface contains all members in A.</td>
	<td>True if classes Array or Dictionary contains all members of interface, False otherwise</td>
	<td>True if class Dictionary contains all members of interface, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Container</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>True if container type and key/value types match exactly, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Dictionary</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>True if all keys match the key type and values match the value type (if applicable), False otherwise</td>
	<td>True if all keys match the key type and values match the value type (if applicable), False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Enum</strong></td>
	<td>Maybe</td>
	<td>True if value type of enum value B matches concrete type A</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True if enum types match, false otherwise</td>
	<td>False</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Callback</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True if function signatures match, False otherwise</td>
	<td>False</td>
</tr>
<tr>
	<td><strong>Null</strong></td>
	<td>Maybe</td>
	<td>False</td>
	<td>Maybe if one of the poly types in B matches A, False otherwise</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>False</td>
	<td>True</td>
</tr>
</tbody>
</table>

<p>The type checker can run at three different levels based on your level of comfort with ambiguity.</p>

<ol>
<li><strong>Silent</strong> - Type match failures are marked as errors, but ambiguity is ignored</li>
<li><strong>Warning</strong> - Type match failures are marked as errors, and ambiguity is marked as a warning</li>
<li><strong>Error</strong> - Type match failures and ambiguity are marked as errors</li>
</ol>

<p>Compiling a code base with ambiguity muted can find obvious type errors, while compiling code when erroring on ambiguity requires adding type scaffolding throughout the code. Monkey Types is designed to allow you to build towards aggressive typing if you choose to, while still adding value if you don&#8217;t.</p>

<h2 id="typingwithinfunctions">Typing Within Functions</h2>

<p>Up until now we have been explicitly adding type scaffolding. While this makes for very readable and explicit code, it can add lots of boilerplate to implementation.</p>

<p>Unlike with class instance variables, the Monkey Types system will infer the type of a local variable by tracking assignments.</p>

<pre><code class="typescript">import Toybox.Lang;
import OldMacDonaldsFarm;

function handleDog(dog as Dog, here as Array, there as Array, everywhere as Array) {
    here.add(dog.woofWoof());
    there.add(dog.woofWoof());
    everywhere.add(dog.woofWoof());
}

function handleCat(cat as Cat, here as Array, there as Array, everywhere as Array) {
    here.add(cat.meowMeow());
    there.add(cat.meowMeow());
    everywhere.add(cat.meowMeow());
}

function eieio() {
    var here = [], there = [], everywhere = [];
    // Animal will be typed as a Dog based
    // on the assignment. No need to declare
    // it's type
    var animal = new OldMacDonaldsFarm.Dog();
    // Allowed, animal is currently assigned a Dog value
    handleDog(animal, here, there, everywhere);
    // Animal will now be typed as a Cat based on
    // the assignment
    animal = new OldMacDonaldsFarm.Cat();
    // Allowed, animal is currently assigned a Cat value
    handleCat(animal, here, there, everywhere);
}
</code></pre>

<p>The inference will follow through branches. If the type is unclear based on which branch is taken, the type system will make a poly type of the options until the next assignment.</p>

<pre><code class="typescript">import Toybox.Lang;

function process(a as Boolean) as Boolean? {
    var x = null;

    if(a) {
        x = true;
    }
    // At this point, x is now the poly type
    // Boolean or Null
    return x;
}
</code></pre>

<p>When a value has a known type definition, the type checker will validate if method calls are allowed.</p>

<pre><code class="typescript">import Toybox.Lang;

class A {
    function foo() {};
    function bar() {};
}

function process() {
    var a = new A();
    a.foo(); // Allowed
    a.bar(); // Allowed
    a.fonz(); // Not allowed
}
</code></pre>

<p>With container types, it is also possible to bind a type to the initialized value. This will put controls on what can be assigned to the container, but allow the local to have any value.</p>

<pre><code class="typescript">import Toybox.Lang;

function example() {
    var a = {} as Dictionary&lt;String, String&gt;;
    a[&quot;key&quot;] = &quot;value&quot; // &lt;-- Assignments to a's value must obey type

    a = null; // &lt;-- a is Any and can be assigned to null
}
</code></pre>

<h3 id="returnvaluesandvoid">Return Values and Void</h3>

<p>By default functions return Any. If you bind a type to a function return value, the type checker will ensure that you return values of that type.</p>

<pre><code class="typescript">import Toybox.Lang;

function isTrue() as Boolean {
    return &quot;true&quot;; // Not allowed
}
</code></pre>

<p>If your function does not have a return value, you can use the <code>Void</code> type. This will ensure the function doesn&#8217;t return values and error if a function tries to assign the return value of the function.</p>

<h3 id="anyandtypeambiguity">Any and Type Ambiguity</h3>

<p>Any function parameter without a bound type will be of type Any. The ambiguity of the parameter will percolate to any member it interacts with in an expression. If you provide all type definitions, type checking can protect them from many kinds of common errors. However, just a little ambiguity can prevent any level of checking. Take this example where a function has a result check but does not have a argument type for <code>a</code>.</p>

<pre><code class="typescript">import Toybox.Lang;

function foo(a) as Integer? {
    // a is of type Any, so Monkey Types can't identify what doThis() is being called
    var x = a.doThis();
    // x is of type Any, so we can't know what the result type is
    var y = x + 3;
    // What is Y? What is Why? What is Love?
    return y;
}
</code></pre>

<p>Because <code>a</code> is Any, Monkey Types can&#8217;t make any determination on any members of it, and by proxy Monkey Types can&#8217;t make determination on the results of accessing those members.</p>

<h3 id="typecasting">Type Casting</h3>

<p>The <code>as</code> keyword can also be used in an expression to type cast a value to another type. This can be useful if the type is not clear to the type system.</p>

<pre><code class="typescript">import Toybox.WatchUi;

function process(a as View) {
    (a as MyView).specialMyViewMethod();
}
</code></pre>

<h3 id="runtimetypechecking">Runtime Type Checking</h3>

<p>One of the goals of Monkey Types was to not add any runtime overhead. This allows Monkey Types to work on all Connect IQ compatible products out of the gate, but it does add a cost when it comes to runtime type checking. Put simply: while at compile time you have access to an expressive type system, at runtime <code>instanceof</code> and <code>has</code> have the same limits as they had before. For cases involving poly types of concrete types this can work fine.</p>

<pre><code class="typescript">import Toybox.Lang;

function example(x as Number or Float) as Boolean {
    switch(x) {
        case instanceof Number:
            doNumberImpl(x);
            break;
        case instanceof Float:
            doFloatImpl(x);
            break;
    }
}
</code></pre>

<p>Unfortunately not every scenario can be resolved this way. For example, lets say we had the following scenario:</p>

<pre><code class="typescript">typedef Nimble as interface {
    function isNimble() as Boolean;
};

typedef Quick as interface {
    function isQuick() as Boolean;
};

function handleCandleStick(jack as Nimble or Quick) {
    if(jack instanceof Nimble and jack instanceof Quick) {
        if(jack.isNimble() and jack.isQuick() and jack has :jumpOverCandleStick) {
            jack.jumpOverCandleStick();
        }
    }
}
</code></pre>

<p>In the case of <code>handleCandleStick</code> the interfaces <code>Nimble</code> and <code>Quick</code> are lexical types and only exist at compile time. This will cause a compiler error because <code>instanceof</code> can only be used on concrete classes and not lexical types. In this case we can use <code>has</code> to resolve this issue.</p>

<pre><code class="typescript">function handleCandleStick(jack as Nimble or Quick) {
    if(jack has :isNimble and jack has :isQuick and jack has :jumpOverCandleStick) {
        if(jack.isNimble() and jack.isQuick()) {
            jack.jumpOverCandleStick();
        }
    }
}
</code></pre>

<h3 id="if-splitting">If-Splitting</h3>

<p>In languages like Java, an object&#8217;s type is assumed to be whatever it was declared to be. This can lead to some very redundant casting or generation of lots of unnecessary locals to communicate to the Compiler that something isn&#8217;t what it was declared to be.</p>

<pre><code class="java">public boolean foo(SomeInterfaceType x) {
    if(x instanceof SomeConcreteType) {
        // My life will just be easier if I make
        // a new variable, even though it should
        // be possible to assume that x is
        // a SomeConcreteType
        SomeConcreteType y = (SomeConcreteType)x;
        // Do operations on y
    }
}
</code></pre>

<p>The Monkey C type system will take advantage of if-splitting, where the branch expression causes the types for variables to mutate within the true and false cases.</p>

<pre><code class="typescript">import Toybox.Lang;

public function foo(x as Number?) as Boolean {
    if(x != null) {
        // Within this block assume x is Number and not null
    } else {
        // Within this block assume x is null
    }
}
</code></pre>

<p>The ==, !=, and <code>instanceof</code> operators will mutate the types based on the following rules</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">type</th>
	<th style="text-align:left;">==</th>
	<th style="text-align:left;">!=</th>
	<th style="text-align:left;">instanceof</th>
	<th style="text-align:left;">!instanceof</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Any</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Concrete</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Poly</td>
	<td style="text-align:left;">If == is <code>null</code>, mutate to Null type</td>
	<td style="text-align:left;">if != is <code>null</code>, mutate to poly type minus <code>null</code>.</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Mutate type to poly type minus type from <code>instanceof</code></td>
</tr>
<tr>
	<td style="text-align:left;">Interface</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Mutate type to <code>instanceof</code> type</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Container</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Dictionary</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Enum</td>
	<td style="text-align:left;">Mutate to enum value type</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Callback</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
<tr>
	<td style="text-align:left;">Null</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
	<td style="text-align:left;">Ignore</td>
</tr>
</tbody>
</table>

<p>Expressions can also be modified using the &amp;&amp; and || operators. With the &amp;&amp; operator, the mutation will carry through the expression, being further modified as the expression continues.</p>

<pre><code class="typescript">import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    // In the first clause, x is modified to remove the null
    // from the poly type. In the second clause, the new polytype
    // is modified to be a String concrete type.
    if(x != null &amp;&amp;
       x instanceof String) {
        // Within this block assume x is a string
    }
}
</code></pre>

<p>With || operators, a new poly type is created with the results of both operations</p>

<pre><code class="typescript">import Toybox.Lang;

typedef Addable as Number or Float or Long or Double or String;

public function foo(x as Addable?) {
    if(x instanceof Number ||
       x instanceof Float) {
        // Within this block assume x is a Number or Float
    }
}
</code></pre>

<p>When if-splitting on member variables, all type mutations will be removed if a function is invoked.</p>

<h2 id="typingmodulesandclasses">Typing Modules and Classes</h2>

<p>Class member variables are bound to type Any by default. Unlike local variables, member variables are not type inferenced based on assignment. Adding type scaffolding to your member variables and names to your enumerations will allow for stronger type checking. Constants are typed based on assignment.</p>

<pre><code class="typescript">class Example {
    // Member variable
    private var _x as Number = 0;

    // Enum values can be explicitly assigned, or by default will
    // be numerically incremented values.
    enum NamedEnum {
        NAMED_ENUM;
    }

    // Constants assume their type by assignment
    private const _constant = &quot;Constant&quot;;
}
</code></pre>

<p>If you add type scaffolding, you must either initialize the variable or allow it to be <code>null</code>. The below example will cause a compiler error:</p>

<pre><code class="typescript">import Toybox.Lang;
import Toybox.System;

// Don't shoot
class Messenger {
    private var _message as String;

    public function shareTheMessage() as Void {
        System.println(_message);
    }
}
</code></pre>

<p>The reason for the error is that <code>_message</code> is declared as a String, but left alone it&#8217;s initialized as <code>null</code>. Module variables either have to be initialized at declaration or allowed to be <code>null</code>, while object members can be initialized in the <code>initialize</code> function, as well. The following would address the error:</p>

<pre><code class="typescript">import Toybox.Lang;
import Toybox.System;

// Don't shoot
class Messenger {
    private var _message as String;

    public function initialize() {
       // Initialize message
        _message = &quot;&quot;;
    }

    public function shareTheMessage() {
        System.println(_message);
    }
}
</code></pre>

<h3 id="typesandinheritance">Types and Inheritance</h3>

<p>When extending classes, the type system will use the following rules:</p>

<ol>
<li>If you extend a function from a parent with the same number of arguments but do not add type decoration, the types for the arguments and return value will be transferred verbatim from the parent implementation</li>
<li>If you extend a function from a parent with the same number of arguments and add type decoration, you must match the number of arguments and type decoration exactly or the compiler will error</li>
</ol>

<p>This allows for existing Monkey C code that extends <code>Toybox</code> types to take advantage of type checking without having to add any type decoration.</p>

<h2 id="applicationscopetypechecking">Application Scope Type Checking</h2>

<p>The type checker attempts to validate that any member fetched from a module or class is available in all of the same application scopes as the caller. If the developer is confident their code is application scope safe and the type checker still complains, this check can be disabled for background or glance scopes using the annotations <code>:typecheck(disableBackgroundCheck)</code> or <code>:typecheck(disableGlanceCheck)</code>, respectively. To disable checks for both background and glance scopes, use the annotation <code>:typecheck([disableBackgroundCheck, disableGlanceCheck])</code>.</p>

<h1 id="exceptionsanderrors">Exceptions and Errors</h1>

<p>Monkey C supports structured exception handling for non-fatal errors from which there can be recovery. The syntax should be familiar for Java and Javascript developers:</p>

<pre><code class="java">try {
    // Code to execute
}
catch( ex instanceof AnExceptionClass ) {
    // Code to handle the throw of AnExceptionClass
}
catch( ex ) {
    // Code to catch all execeptions
}
finally {
    // Code to execute when
}
</code></pre>

<p>You can use the <code>throw</code> keyword to throw an exception.</p>

<h2 id="creatinganexception">Creating an Exception</h2>

<p>If you are creating your own exception, follow these rules:</p>

<ul>
<li>Extend <code>Toybox.Lang.Exception</code></li>
<li>Initialize the superclass in the initializer</li>
<li>Assign a string message to the <code>mMessage</code> member variable</li>
</ul>

<p>For example, an app specific exception can be defined as follows:</p>

<pre><code class="typescript">class AppSpecificException extends Lang.Exception {
    //! Constructor
    //! @param msg Message explaining cause
    function initialize(msg) {
        Exception.initialize();
        self.mMessage = msg;
    }
}
</code></pre>

<h2 id="errors">Errors</h2>

<p>Because Monkey C uses dynamic typing, there are many errors for which the compiler cannot check. If the error is of high enough severity, it will raise an fatal API error and cause your app to terminate at runtime. These errors cannot be caught.</p>

<dl>
<dt>Array Out Of Bounds</dt>
<dd>An attempt is being made to reference an array outside of its allocated bounds</dd>

<dt>Circular Dependency</dt>
<dd>There is a loop in the dependency graph of a module or object that prevents a module or object from being constructed</dd>

<dt>Communications Error</dt>
<dd>An error has occurred in <a href="https://en.wikipedia.org/wiki/Bluetooth_low_energy" title="Bluetooth low energy">BLE</a> communications</dd>

<dt>File Not Found</dt>
<dd>The app file could not be found, which is usually caused when trying to load a resource from the app file</dd>

<dt>Illegal Frame</dt>
<dd>The return address on the stack is corrupted</dd>

<dt>Initializer Error</dt>
<dd>An error occurred in an initializer</dd>

<dt>Invalid Value</dt>
<dd>An argument passed to a function or method is invalid</dd>

<dt>Null Reference</dt>
<dd>A value is being requested from a null value</dd>

<dt>Out of Memory</dt>
<dd>Indicates no more system memory is available for allocation</dd>

<dt>Permission Required</dt>
<dd>An attempt was made to use a restricted API without permission</dd>

<dt>Stack Underflow</dt>
<dd>The stack pointer went past the bottom of the stack memory limit</dd>

<dt>Stack Overflow</dt>
<dd>The stack pointer went past the top of the stack memory limit</dd>

<dt>Symbol Not Found</dt>
<dd>An attempt was made to access a variable or method that does not exist in the specified object or method</dd>

<dt>System Error</dt>
<dd>A generic error used by the Toybox APIs for fatal errors</dd>

<dt>Too Many Arguments</dt>
<dd>Too many arguments used by a method, which are currently limited to 10 arguments</dd>

<dt>Too Many Timers</dt>
<dd>Too many <code>Timer::Timer</code> objects for the target device were started</dd>

<dt>Unexpected Type</dt>
<dd>Indicates an operation being done on a variable that is unsupported by the type; for example, trying to perform a bitwise OR on two string</dd>

<dt>Unhandled Exception</dt>
<dd>An <code>Exception</code> was thrown but was not caught by an exception handler</dd>

<dt>Watchdog Tripped</dt>
<dd>A Monkey C function has executed for too long; watchdogs prevent a Monkey C program from hanging the system via an infinite loop</dd>
</dl>

<h1 id="annotations">Annotations</h1>

<p>Monkey C allows associating symbols with class or module methods and variables. These symbols are currently written into the <code>debug.xml</code> file generated by the compiler, but may be used in the future to add new features without changing the Monkey C grammar:</p>

<pre><code class="java">(:debug) class TestMethods
{
    (:test) static function testThisClass( x )
}
</code></pre>

<p>The following annotations have special meanings to the Monkey C compiler:</p>

<dl>
<dt><strong>:background</strong> <!-- The bold delimiter is required here because there's no way to escape the leading ':' in MMD --></dt>
<dd>Denotes code blocks available to the Background process.</dd>

<dt><strong>:debug</strong></dt>
<dd>Code blocks decorated with this annotation will not be included in release builds at compile time.</dd>

<dt><strong>:glance</strong></dt>
<dd>Denotes code blocks available to when running in Glance Mode.</dd>

<dt><strong>:release</strong></dt>
<dd>Code blocks decorated with this annotation will not be included in debug builds at compile time.</dd>

<dt><strong>:test</strong></dt>
<dd>Denotes test cases that are used as Run No Evil unit tests and are excluded from the application at compile time.</dd>

<dt><strong>:typecheck</strong></dt>
<dd>Code blocks decorated with this annotation can direct the type checker to perform / avoid certain checks.</dd>

<dt><strong>:initialized</strong></dt>
<dd>Member variables decorated with this annotation directs the type checker that it is safe to assume the variable will be initialized before it is referenced.</dd>
</dl>

<h1 id="codingconventions">Coding Conventions</h1>

<p>Here are guidelines for Monkey C code:</p>

<h2 id="naming">Naming</h2>

<ul>
<li>Modules and Classes are camel-cased with the first letter in upper case.</li>
<li>Functions are camel-cased with the first letter always being lower case.</li>
<li>Private class member variables are camel cased with the first character being an underscore (_) and then the first letter lower case.</li>
<li>Public class member variables are camel cased with the first letter lower case.</li>
<li>Module variables should be camel cased with a lower cased first letter</li>
<li>Enums must have a common prefix, e.g. <em>COLOR_RED</em>, <em>COLOR_BLUE</em>.</li>
<li>In POMO (Plain Old Monkey C Objects) it is okay to have all public members.</li>
</ul>

<h2 id="source">Source</h2>

<ul>
<li>Put one class per Monkey C source file.</li>
<li>Monkey C code should use spaces aligned four spaces per indent level. The Monkey C editor will automatically convert spaces to tabs and remove trailing white space.</li>
<li>When defining modules, classes, functions, and enums, put the opening brace on the same line as the definition and the closing brace aligned with the first character as the definition.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<ul>
<li>Avoid pure global variables when possible.</li>
<li>Because modules are not purely lexical and have runtime memory cost, putting class definitions into the global module is acceptable.</li>
<li>Avoid having public static members in class definitions; instead move those definitions into the parent module.</li>
<li>In the first line of your class initialize function, always call the superclass initialize.</li>
</ul>

<h2 id="sample">Sample</h2>

<p>Here is a sample:</p>

<pre><code class="C++">class SampleName extends Toybox.Application.AppBase
{
    public var publicVar;
    private var _privateVar;

    function initialize() {
        AppBase.initialize();
    }
    // onStart() is called on application start up
    function onStart(state) {
    }

    // onStop() is called when your application is exiting
    function onStop(state) {
    }

    // Return the initial view of your application here
    function getInitialView(){
        return [new SampleNameView(), new SampleNameDelegate()];
    }
 }
</code></pre>

<h1 id="compileroptions">Compiler Options</h1>

<p>The following are command line options for <code>monkeyc</code> :</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Short Option</th>
	<th>Long Option</th>
	<th>Argument</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>-d</code></td>
	<td><code>--device</code></td>
	<td>Device identifier</td>
	<td>Required for building a device executable. Specifies the device to target.</td>
</tr>
<tr>
	<td><code>-e</code></td>
	<td><code>--package-app</code></td>
	<td>None</td>
	<td>Specifies that output is an <code>IQ</code> file for uploading to the app store.</td>
</tr>
<tr>
	<td><code>-f</code></td>
	<td><code>--jungles</code></td>
	<td>Colon separated list of paths to jungle files</td>
	<td><strong>Required</strong>. Each jungle specifies a project to include, which can include one app project and multiple monkey barrel projects.</td>
</tr>
<tr>
	<td><code>-g</code></td>
	<td><code>--debug</code></td>
	<td>None</td>
	<td>Prints the debug output.</td>
</tr>
<tr>
	<td><code>-h</code></td>
	<td><code>--help</code></td>
	<td>None</td>
	<td>Prints the help information.</td>
</tr>
<tr>
	<td><code>-k</code></td>
	<td><code>--profile</code></td>
	<td>None</td>
	<td>Includes profiler information in the executable. When an executable with profiler information runs on device, the device will generate profiler information that can be analyzed in the simulator.</td>
</tr>
<tr>
	<td><code>-l</code></td>
	<td><code>--typecheck</code></td>
	<td><code>0</code> = off, <code>1</code> = gradual, <code>2</code> = informative, <code>3</code> = strict</td>
	<td>See the <a href="./LearningMonkeyC.html">Monkey Types</a> section for more information.</td>
</tr>
<tr>
	<td><code>-o</code></td>
	<td><code>--output</code></td>
	<td>File to output</td>
	<td><strong>Required</strong>. Specifies the output of the compiler.</td>
</tr>
<tr>
	<td><code>-O</code></td>
	<td><code>--optimization</code></td>
	<td><code>0</code> = None, <code>1</code> = Basic,<code>2</code> = Fast Optimizations, <code>3</code> = Slow Optimizations, <code>p</code> = Performance Optimizations, <code>z</code> = Code Space Optimizations</td>
	<td>Default is <code>1</code> for building in debug, and <code>2</code> for building in release. The numeric level can be suffixed with the letters, so <code>-O 2pz</code> is an allowed argument.</td>
</tr>
<tr>
	<td><code>-r</code></td>
	<td><code>--release</code></td>
	<td>None</td>
	<td>Do not include debug information in PRG.</td>
</tr>
<tr>
	<td><code>-t</code></td>
	<td><code>--unit-test</code></td>
	<td>None</td>
	<td>Include unit tests in the build.</td>
</tr>
<tr>
	<td><code>-v</code></td>
	<td><code>--version</code></td>
	<td>None</td>
	<td>Prints the compiler version.</td>
</tr>
<tr>
	<td><code>-w</code></td>
	<td><code>--warn</code></td>
	<td>None</td>
	<td>Off by default. Displays build warnings generated by the compiler.</td>
</tr>
<tr>
	<td><code>-y</code></td>
	<td><code>--private-key</code></td>
	<td>Path to developer key</td>
	<td><strong>Required</strong>. Specifies the developer key to use for signing the <code>PRG</code> or <code>IQ</code> file.</td>
</tr>
</tbody>
</table>

<h2 id="debuglogging">Debug Logging</h2>

<p>If you encounter a bug with the <code>monkeyc</code> compiler you will need to generate logs to provide with your report. Here are the options to create debug logs:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Long Option</th>
	<th>Argument</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>--debug-log-level</code></td>
	<td><code>0</code> = Errors, <code>1</code> = Basic Debug, <code>2</code> = Intermediate Debug, <code>3</code> = Verbose Debug</td>
	<td>Specifies the verbosity level for the output.</td>
</tr>
<tr>
	<td><code>--debug-log-output</code></td>
	<td>Path to log file to generate</td>
	<td>Specifies the path to the log file to create</td>
</tr>
<tr>
	<td><code>--debug-log-device</code></td>
	<td>Device identifier</td>
	<td>Allows limiting logs to a specific device when building a Monkey Barrel.</td>
</tr>
</tbody>
</table>

<p>Be aware that the log levels include increasingly more information about your source project. If you want to keep your project information private, limit the logging level to <code>1</code> or less. More verbosity will make it easier for Garmin to debug any issues.</p>

<h2 id="featurecontroloptions">Feature Control Options</h2>

<p>These options are used for controlling different features:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Long Option</th>
	<th>Argument</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>--disable-api-has-check-removal</code></td>
	<td>None</td>
	<td>Disables optimizing out API has checks.</td>
</tr>
<tr>
	<td><code>--disable-v2-opcodes</code></td>
	<td>None</td>
	<td>Disables the generation of V2 opcodes.</td>
</tr>
</tbody>
</table>

<h2 id="privateoptions">Private Options</h2>

<p>These options are typically already set and should not be necessary to use:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th>Short Option</th>
	<th>Long Option</th>
	<th>Argument</th>
	<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td><code>-a</code></td>
	<td><code>--apidb</code></td>
	<td>Path to <code>api.db</code></td>
	<td>Specifies path to API linking information.</td>
</tr>
<tr>
	<td><code>-b</code></td>
	<td><code>--apimir</code></td>
	<td>Path to <code>api.mir</code></td>
	<td>Specifies path to API type information.</td>
</tr>
<tr>
	<td><code>-i</code></td>
	<td><code>--import-dbg</code></td>
	<td>Path to <code>api.debug.xml</code></td>
	<td>Path to the API debug information.</td>
</tr>
<tr>
	<td><code>-p</code></td>
	<td><code>--project-info</code></td>
	<td>Path to <code>projectInfo.xml</code></td>
	<td>Path to SDK project definitions.</td>
</tr>
</tbody>
</table>

<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p>This is different than Monkey Typing, where a thousand monkeys over infinite time write the works of Shakespeare. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:2">
<p>Not that this ever happened to the author. <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:3">
<p>Do not forget to match your bling with pieces of flair; you can&#8217;t have enough of either. <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:4">
<p>Tofu for the vegetarians, BBQ for Kansans&hellip; <a href="#fnref:4" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:5">
<p>It is understood that this is controversial. First, <code>as</code> has a whole new meaning now in the grammar, and using it for module renaming is confusing. Also, renaming modules in Monkey C has made it really difficult to write good shareable example code because everyone renames every module to their own preference. Yes, <code>Gregorian</code> is a big word and is annoying to type, but thats what we have auto-complete for. <a href="#fnref:5" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:6">
<p>The <code>method</code> method that returns <code>Method</code> should not be confused with &#8220;The Method Method&#8221;, my upcoming self help book on evaluating self help books. <a href="#fnref:6" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:7">
<p>I just met you | and this is crazy | but I&#8217;m an Any | so type match? Maybe&#8230; <a href="#fnref:7" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

</ol>
</div>


</body>
</html>
